from collections import defaultdict
from concurrent.futures import as_completed, ThreadPoolExecutor
import itertools
from itertools import cycle
from typing import Iterable, Callable, Union, List, Tuple, Sequence

from dash import dcc, html

from plotly.colors import DEFAULT_PLOTLY_COLORS
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

from ibmdata import DataFrame

from .data import verify_columns_in_dataframe

MAX_PARALLEL_WORKERS = 8
COLOR_LIST = px.colors.qualitative.Plotly  # NOT the same as plotly.colors.DEFULT_PLOTLY_COLORS


def graph_object(graph_id: Union[str, dict], height: str = "450px", in_loading: bool = True):
    """
    returns a graph object with useful defaults set
    """
    graph = dcc.Graph(
        id=graph_id,
        style=dict(height=height),
        config=dict(
            displaylogo=False,
        ),
    )
    return dcc.Loading(graph, style=dict(height=height)) if in_loading else graph


def empty_figure(msg: str = "", blank: bool = False, width: int = None, height: int = None) -> go.Figure:
    """
    returns an empty figure with optional msg displayed in the center
    """
    layout = dict(
        annotations=[
            go.layout.Annotation(text=msg, x=0.5, y=0.5, xref="paper", yref="paper", font_size=16, showarrow=False)
        ]
    )

    if blank:
        layout.update(
            xaxis=dict(showgrid=False, showline=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, showline=False, showticklabels=False),
        )

    if width is not None:
        layout["width"] = width
    if height is not None:
        layout["height"] = height

    return go.Figure(layout=layout)


def generate_discrete_colormap(labels: Iterable, colors: Iterable = None) -> dict:
    """
    generates a fixed colormap given a sequence of values
    """
    colors = colors or DEFAULT_PLOTLY_COLORS
    return {label: color for label, color in zip(sorted(list(labels)), itertools.cycle(colors))}


def get_sunburst_segment_info_from_cd(click_data, has_core: bool = False) -> List:
    """
    extract the id of the currently selected px.sunburst sector based on clickData. This is intended for px.sunbursts
    created using the "path" argument. This is not straight forward because clickData needs to be handled differently
    depending on whether the user is moving "towards the edge" of the sunburst vs. clicking on the center of the chart
    to move "inward."

    :param click_data: the px.sunburst's clickData property
    :param has_core: set to True if the sunburst has a blank "core." This makes the formatting nicer if there's a lot of
    sectors in the first ring
    :return: list generated by calling .split('/') on the sector_id. This can be used to filter the df used to generate
    the sunburst
    """
    segment_info = []
    if click_data:
        click_data = click_data["points"][0]
        entry = click_data.get("entry")  # name of the last sector that was in the sunburst center
        current_id = click_data.get("id")  # id of the sector clicked on. formatted like "P9/NIMBUS/MONZA"
        label = click_data.get("label")  # name of the sector clicked on (should be equal to current_id.split('/')[-1]

        if label == entry:
            # user clicked on sunburst center, attempting to go back a level. So, should drop last name in current_id
            segment_info = current_id.split("/")[:-1]

        else:  # the sector the user clicked on just became the center, so can just use segment_info
            segment_info = current_id.split("/")

        if has_core:
            segment_info = segment_info[1:]

    return segment_info


def plot_matrix_table(
    data: DataFrame, col_vars: list, row_vars: list, plot_func: Callable, plot_kwargs: dict = None, workers: int = 1
) -> html.Div:
    """
    Builds a sparse matrix of plots by subsetting data by row_vars and col_vars which are lists of columns
    in data.  Returns a scrollable div containing an html table view of the matrix.
    The value in each "cell" is whatever plot_func returns when passed plot_kwargs, presumably
    a plot of some kind but it doesn't have to be.  If workers is > 1 then cells are computed in parallel.

    If you just want a dict of plots instead of an html table call generate_plot_matrix instead.
    """
    plots = generate_plot_matrix(data, col_vars, row_vars, plot_func, plot_kwargs, workers)
    return html.Div(
        html.Table(
            [
                table_header(plots),
                table_body(plots),
            ],
            className="table table-bordered table-sm",
        ),
        className="table-responsive",
    )


def generate_plot_matrix(
    data: DataFrame,
    col_vars: list,
    row_vars: list,
    plot_func: Callable,
    plot_kwargs: dict = None,
    workers: int = 1,
    drop_nan_groups: bool = True,
) -> dict:
    """
    Builds a sparse matrix of plots by subsetting data by row_vars and col_vars which are lists of columns
    in data.  Returns a row major dictionary representation of the matrix where only row & col combinations
    with data exist.  The value in each "cell" is whatever plot_func returns when passed plot_kwargs, presumably
    a plot of some kind but it doesn't have to be.  If workers is > 1 then cells are computed in parallel.

    {
        row_var: {
            col_var: return value of plot_func or error string,
            ...
        },
        ...
    }
    """
    verify_columns_in_dataframe(data, col_vars)
    verify_columns_in_dataframe(data, row_vars)
    workers = min(MAX_PARALLEL_WORKERS, max(1, workers))
    plot_kwargs = dict() if plot_kwargs is None else plot_kwargs
    plots = defaultdict(dict)
    if (not row_vars) and (not col_vars):  # not much of a "matrix" in this case, but keeps behaviour consistent
        plots[("",)][("",)] = plot_func(data, **plot_kwargs)
        return plots

    if workers < 2:
        for grp_values, grp_data in data.groupby(row_vars + col_vars, dropna=drop_nan_groups):
            grp_values = grp_values if isinstance(grp_values, tuple) else (grp_values,)  # allows row or col vars to==[]
            row_values = grp_values[: len(row_vars)]
            col_values = grp_values[len(row_vars) :]
            try:
                plots[row_values][col_values] = plot_func(grp_data, **plot_kwargs)
            except Exception as ex:
                plots[row_values][col_values] = f"ERROR: {ex}"
    else:
        with ThreadPoolExecutor(max_workers=workers) as pool:
            futures = dict()
            for grp_values, grp_data in data.groupby(row_vars + col_vars, dropna=drop_nan_groups):
                futures[pool.submit(plot_func, grp_data, **plot_kwargs)] = grp_values

            for future in as_completed(futures):
                grp_values = futures[future]
                row_values = grp_values[: len(row_vars)]
                col_values = grp_values[len(row_vars) :]
                try:
                    plots[row_values][col_values] = future.result()
                except Exception as ex:
                    plots[row_values][col_values] = f"ERROR: {ex}"

    return plots


def table_header(plots: dict) -> html.Thead:
    columns = _all_columns_from_plots(plots)
    depth = _index_depth(columns[0])
    cells = _cell_groups(depth, columns)
    row_index_depth = _index_depth(tuple(plots.keys())[0])
    corner_cell = html.Th(colSpan=row_index_depth, rowSpan=depth)
    return html.Thead(
        [html.Tr([corner_cell] + _make_th(cells[0]))] + [html.Tr(_make_th(row)) for row in cells[1:]],
        className="thead-dark",
    )


def _index_depth(index_item) -> int:
    if isinstance(index_item, (tuple, list, set)):
        return len(index_item)
    return 1


def _cell_groups(depth, labels):
    cells = tuple(list() for _ in range(depth))
    for col in labels:
        if not isinstance(col, (tuple, list, set)):
            col = (col,)
        for index, item in enumerate(col):
            cells[index].append(item)
    return cells


def _make_th(columns: list):
    return [html.Th([key], colSpan=len(tuple(sequence))) for key, sequence in itertools.groupby(columns)]


def _all_columns_from_plots(plots: dict) -> list:
    return sorted(set(col for columns in plots.values() for col in columns))


def table_body(plots: dict, elements_are_dcc_graphs: bool = False):
    rowlabels = sorted(plots.keys())
    depth = _index_depth(rowlabels[0])
    cells = _cell_groups(depth, rowlabels)

    spans = tuple(list() for _ in range(depth))
    for index, level in enumerate(cells):
        for _, group in itertools.groupby(level):
            span = len(tuple(group))
            spans[index].append(span)
            while span > 1:
                spans[index].append(0)
                span -= 1

    all_columns = _all_columns_from_plots(plots)
    rows = []

    for rowlabel, span in zip(rowlabels, zip(*spans)):
        columns = plots[rowlabel]

        if depth < 2:
            rowlabel = (rowlabel,)

        rows.append(
            html.Tr(
                [html.Th(label, rowSpan=labelspan) for label, labelspan in zip(rowlabel, span) if labelspan > 0]
                + [
                    html.Td(
                        columns[col]
                        if elements_are_dcc_graphs
                        else dcc.Graph(figure=columns[col], config=dict(displayModeBar=False))
                        if col in columns and not isinstance(columns[col], str)
                        else columns.get(col, ""),
                    )
                    for col in all_columns
                ]
            )
        )

    return html.Tbody(rows)


def make_plot_gallery(
    df: DataFrame,
    col_vars: List[str],
    row_vars: List[str],
    chunk_vars: List[str],
    plot_func: Callable,
    plot_func_args: dict,
    max_cols: int = 20,
    max_rows: int = 20,
    max_chunks: int = 20,
    graph_id_type: str = "",
    cell_width: int = 200,
    title_font_size: int = 10,
    show_plot_titles: bool = True,
    include_headers: bool = False,
    chunk_div_class_name: str = "pretty-container mb-5",
    plot_cell_class_name: str = "white-container",
    chunk_title_suffix: str = "",
):
    """
    function to create gallery of figures. Plots are grouped into grids based on chunk_vars,
    row/column within each grid corresponds to row_vars/col_vars.
    :param df: data
    :param col_vars: list of columns in df used to facet into columns
    :param row_vars: list of columns in df used to facet into rows
    :param chunk_vars: list of columns in df used to group plots into separate Divs
    :param plot_func: callable to create single plot. should take filtered df as first input, plus kwargs
    :param plot_func_args: dict of kwargs, passed into plot_func
    :param max_cols: plots won't be generated if any group has more columns than this value
    :param max_rows: plots won't be generated if any group has more rows than this value
    :param max_chunks: plots won't be generated if df.groupby(chunk_vars).ngroups exceeds this value
    :param graph_id_type: 'type' value for id dict in each dcc.Graph (used for pattern matching callbacks)
    :param cell_width: width in px for each plot cell
    :param title_font_size: size in pt for plot titles
    :param show_plot_titles: bool, should row/col vars be displayed as title on each plot?
    :param include_headers: If True, grids are styled like a table with row/col headers (just like plot_matrix_table)
    :param chunk_div_class_name: css className given to each chunk
    :param plot_cell_class_name: css className given to each plot's dbc.Col
    :param chunk_title_suffix: text to append onto each chunk div's heading.
    :return: children prop for an html.Div (html.Div, or str error message if error occurs)
    """

    # if single column provided as str for any axis, replace with single element list:
    col_vars = [col_vars] if isinstance(col_vars, str) else col_vars
    row_vars = [row_vars] if isinstance(row_vars, str) else row_vars
    chunk_vars = [chunk_vars] if isinstance(chunk_vars, str) else chunk_vars

    if include_headers:
        # workaround to prevent code for generating table from breaking if rows/cols not both defined
        if not row_vars:
            row_vars = ["ROW"]
            df["ROW"] = 0
        if not col_vars:
            col_vars = ["COL"]
            df["COL"] = 0

    error_message = _verify_grid_columns(df, col_vars, row_vars, chunk_vars, max_cols, max_rows, max_chunks)
    if error_message:
        return error_message

    plot_matrix_kwargs = dict(
        col_vars=col_vars, row_vars=row_vars, plot_func=plot_func, plot_kwargs=plot_func_args, drop_nan_groups=False
    )

    common_grid_kwargs = dict(
        col_vars=col_vars,
        row_vars=row_vars,
        id_type=graph_id_type,
        group_div_class_name=chunk_div_class_name,
        plot_cell_class_name=plot_cell_class_name,
        width=cell_width,
        title_font_size=title_font_size,
        show_headers=include_headers,
        plot_titles=show_plot_titles,
    )

    if chunk_vars and all(chunk_col in df.columns for chunk_col in chunk_vars):
        return html.Div(
            [
                _make_grid_from_plot_dict(
                    generate_plot_matrix(dff, **plot_matrix_kwargs),
                    title=_make_title_str(chunk_vars, chunk_value, sep=", ") + " " + chunk_title_suffix,
                    chunk_val=chunk_value,
                    chunk_vars=chunk_vars,
                    **common_grid_kwargs,
                )
                for chunk_value, dff in df.groupby(chunk_vars, dropna=False)
            ]
        )

    else:
        return _make_grid_from_plot_dict(
            generate_plot_matrix(df, **plot_matrix_kwargs), title=chunk_title_suffix, **common_grid_kwargs
        )


def _verify_grid_columns(df, col_vars, row_vars, chunk_vars, max_cols, max_rows, max_chunks):
    for col_list in [col_vars, row_vars, chunk_vars]:
        if col_list and any(col and col not in df.columns for col in col_list):
            return f"column(s): {[col for col in col_list if col not in df.columns]} not in data"

    # ensure number of plots is within limits
    error_str = "{} has too many unique values ({}). Must be less than {}."
    if chunk_vars:  # should check number of rows/cols within each group
        chunked = df.groupby(chunk_vars)
        n_chunks = chunked.ngroups
        if n_chunks > max_chunks:
            return error_str.format(chunk_vars, n_chunks, max_chunks)

        for c_list, thresh in zip((row_vars, col_vars), (max_rows, max_cols)):
            if c_list:
                counts = chunked.apply(lambda rows: rows.groupby(c_list).ngroups)
                if counts.gt(thresh).any():
                    return f"{c_list} has {counts.max()} unique values in a group! Must be less than {thresh}."

    else:  # can check df.groupby(row_vars).ngroups and df.groupby(col_vars).ngroups globally
        for c_list, thresh in zip((row_vars, col_vars), (max_rows, max_cols)):
            if c_list and df.groupby(c_list).ngroups > thresh:
                return error_str.format(c_list, df.groupby(c_list).ngroups, thresh)


def _make_grid_from_plot_dict(
    plots: dict,
    col_vars: List[str],
    row_vars: List[str],
    chunk_vars: List[str] = None,
    plot_titles: bool = True,
    show_headers: bool = False,
    chunk_val: Tuple = None,
    id_type: str = "",
    width: int = 200,
    title_font_size: int = 10,
    group_div_class_name: str = "",
    plot_cell_class_name: str = "",
    title: str = "",
):
    """convert nested dict of plots (output of generate_plot_matrix) to grid of dcc.Graphs"""
    chunk_vars = [] if chunk_vars is None else chunk_vars
    rows = sorted(list(plots.keys()))
    cols = sorted(list({col for row in plots.keys() for col in plots.get(row, dict()).keys()}))

    plots = {
        row: {
            col: _make_fig_into_dcc_graph(
                plots,
                row,
                col,
                col_vars,
                row_vars,
                cell_width=width,
                title_font_size=title_font_size,
                id_type=id_type,
                chunk_val=chunk_val,
                chunk_vars=chunk_vars,
                show_title=plot_titles,
            )
            for col in cols
        }
        for row in rows
    }

    if show_headers:
        return html.Div(
            [
                html.H4(title) if title else None,
                html.Div(
                    html.Table(
                        [
                            table_header(plots),
                            table_body(plots, elements_are_dcc_graphs=True),
                        ],
                        className="table table-bordered table-sm",
                    ),
                    className="table-responsive",
                ),
            ],
            className="mb-5",
        )
    else:
        return html.Div(
            [
                html.H4(title) if title else None,
                html.Div(
                    [
                        html.Div(
                            [
                                html.Div(
                                    plots[row][col], className=plot_cell_class_name, style={"flex": f"0 0 {width}px"}
                                )
                                for col in cols
                            ],
                            style={"flex-wrap": "nowrap", "display": "flex"},
                        )
                        for row in rows
                    ],
                    style={"flex-wrap": "nowrap", "overflow-x": "auto"},
                ),
            ],
            className=group_div_class_name,
        )


def _make_fig_into_dcc_graph(
    plots: dict,
    row: Tuple,
    col: Tuple,
    col_vars: List[str],
    row_vars: List[str],
    cell_width=200,
    title_font_size=10,
    id_type="",
    chunk_val=(),
    chunk_vars=None,
    show_title=False,
):
    """get plot from plots dict, add title based on grid position"""
    chunk_vars = [] if chunk_vars is None else chunk_vars
    fig = plots.get(row, dict()).get(col, empty_figure("No Data", blank=True))
    if isinstance(fig, str):
        fig = empty_figure(fig, blank=True)

    else:
        title = f"{_make_title_str(col_vars, col)}<br>{_make_title_str(row_vars, row)}"
        n_lines_in_title = title.count("<br>") + 1

        mt = 35 * n_lines_in_title if show_title else 35

        fig.update_layout(
            title=title if show_title else "",
            title_x=0.5,
            margin_b=0,
            margin_t=mt,
            height=cell_width + mt,
            width=cell_width,
            title_font_size=title_font_size,
        )

    g_config = {"displayModeBar": False}
    g_id = _set_graph_id(row, col, chunk_val, row_vars, col_vars, chunk_vars, id_type) if id_type else None
    return dcc.Graph(id=g_id, figure=fig, config=g_config) if id_type else dcc.Graph(figure=fig, config=g_config)


def _make_title_str(names: List[str], values: Tuple[str], sep: str = "<br>") -> str:
    values = values if isinstance(values, tuple) else (values,)  # convert single values to single element tuple
    return sep.join(f"{name}={value}" for name, value in zip(names, values))


def _set_graph_id(
    row: Tuple, col: Tuple, chunk: Tuple, row_vars: List[str], col_vars: List[str], chunk_vars: List[str], id_type: str
) -> dict:
    if not id_type:
        return {}

    row = row if isinstance(row, tuple) else (row,)
    col = col if isinstance(col, tuple) else (col,)
    chunk = chunk if isinstance(chunk, tuple) else (chunk,)

    all_values = [x for x in row + col + chunk if x]
    all_columns = row_vars + col_vars + chunk_vars

    index = "/".join(f"{column_name}={val}" for column_name, val in zip(all_columns, all_values))
    return {"type": id_type, "index": index}


def parse_cell_info_from_prop_id(prop_id: str) -> dict:
    """utility function for using pattern matching callbacks with output of make_plot_gallery.
    dash.callback_context.triggered[0]['prop_id'] contains component_id as a stringified dict.
    If make_plot_gallery() is used, this prop_id will be formatted like:
    '{"index":"test_date=2021-02-01/eqp_id=uflx9490","type":"graph_id_type"}.clickData'

    taking this prop_id as an input, should return a dict of {column: value, ...} like:
    {'test_date': '2020-02-01', 'eqp_id': 'uflx9490'}

    original df can then be filtered like:
    apply_list_of_filters(df, [df[col].eq(val) for col, val in _parse_cell_info_from_prop_id(prop_id).items()])
    """
    if prop_id:
        try:
            index_items = prop_id.split('"index":')[1].split(",")[0].strip('"').split("/")
            list_of_cols = [x.split("=") for x in index_items]
            return {k: v for k, v in list_of_cols}
        except Exception:
            pass

    return dict()


def make_hybrid_wafermap(
    chip_wafermap,
    subdie_wafermap,
    as_scatter=False,
    show_subdie_legend: bool = True,
    symbol_dict: dict = None,
    subdie_border_width: float = 1.0,
    subdie_marker_size: int = 12,
    update_subdie_traces: dict = None,
):
    """
    overlay data from a subdie-level wafermap onto a chip-level wafermap.
    example usecase: overlay failing subdie locations on a wafermap with chips colored by weight
    :param chip_wafermap: chip-level wafermap obtained from ibmdata.plot.wafermap.wafermap()
    :param subdie_wafermap: subdie-level wafermap obtained from ibmdata.plot.wafermap.wafermap()
    :param as_scatter: if True, subdie are overlayed as a scatter plot. Else overlayed as standard cartoon rectangles
    :param show_subdie_legend: bool, should subdie trace names be shown in legend?
    :param symbol_dict: if as_scatter==True, this dict is used to assign marker_symbol to each subdie trace
        keys = unique values contained in color_by_column used for subdie_wafermap
        values = valid plotly symbol names, or ints
    :param subdie_border_width: marker_line_width for subdie points (only used if as_scatter==True)
    :param subdie_marker_size: marker_size for subdie points (only used if as_scatter==True)
    :param update_subdie_traces: dict of kwargs to pass into fig.update_traces() to modify subdie traces
    :return: go.Figure with combined subdie/chip data
    """
    # hide colorscale bar on chip map
    symbol_dict = {} if symbol_dict is None else symbol_dict
    if show_subdie_legend:
        chip_map_has_discrete_coloring = not bool(chip_wafermap.data[0].marker.colorscale)
        chip_wafermap.update_traces(
            marker_showscale=False,
            showlegend=chip_map_has_discrete_coloring,  # only include chip in legend if on discrete scale
        )

    if as_scatter:
        common_keys = ["customdata", "hovertemplate", "legendgroup", "name", "showlegend"]
        subdie_traces = [
            go.Scatter(
                x=bar_trace.x,
                y=bar_trace.base + bar_trace.y / 2,
                marker=bar_trace.marker.to_plotly_json(),
                marker_line_width=subdie_border_width,
                marker_size=subdie_marker_size,
                marker_symbol=symbol_dict.get(bar_trace.name, 0) if symbol_dict else None,
                mode="markers",
                **{key: bar_trace[key] for key in common_keys},
            )
            for bar_trace in subdie_wafermap.select_traces()
        ]
    else:
        if update_subdie_traces:
            subdie_wafermap.update_traces(**update_subdie_traces)

        subdie_traces = subdie_wafermap.data

    chip_wafermap.add_traces(subdie_traces)
    if as_scatter and update_subdie_traces:
        chip_wafermap.update_traces(selector={"type": "scatter"}, **update_subdie_traces)

    chip_wafermap.update_layout(showlegend=show_subdie_legend)
    return chip_wafermap


def _convert_cols_argument_to_dict(cols: Union[str, Sequence[str], dict]) -> dict:
    """return a dict with column names as keys and corresponding trace names as values"""
    if isinstance(cols, str):
        return {cols: cols}
    elif isinstance(cols, Sequence):
        return {c: c for c in cols}
    elif isinstance(cols, dict):
        return cols
    else:
        raise TypeError(f"cols argument must be a str, dict, or list-like. Received {cols}")


def _get_trace_kwargs(overrides: dict, **defaults) -> dict:
    """merge dict of user-provided 'overrides' kwargs with auto-generated default kwargs. Prioritize overrides"""
    return {**defaults, **overrides}


def timeline(
    df: DataFrame,
    x: str,
    bar_cols: Union[str, dict, List[str]],
    scatter_cols: Union[str, dict, List[str]],
    bar_colors: Union[str, List[str]] = COLOR_LIST,
    scatter_colors: Union[str, List[str]] = COLOR_LIST,
    bar_opacity: float = 1.0,
    scatter_symbol: str = "circle",
    scatter_mode: str = "lines+markers",
    trace_overrides: dict = None,
    line_shape: str = "hvh",
    title: str = None,
    bar_axis_title: str = None,
    scatter_axis_title: str = None,
    hovermode: str = "x unified",
    dragmode: str = "select",
    selectdirection: str = "h",
    x_asfreq: str = None,
    sort: bool = True,
) -> go.Figure:
    """
    Helper function for creating a "timeline" style chart. ie a dual-y axis plot with bar trace(s) on one y-axis and
    scatter trace(s) on the other. Example use-case: chart showing yield and volume as a function of test_date.

    :param df: pre-aggregated wide-form DataFrame: there should have one row for each unique value in column 'x,'
        one column for each scatter trace, and one column for each bar trace.
    :param x: column in df to use for x-axis. Typically datetime-like, but doesn't have to be
    :param bar_cols: column(s) to use for bar traces. Can provide a single column (as a str), a list of columns,
        or a dict with keys: column names, and values: aliases to use as trace names. Each provided column will be used
        to create one bar trace.
    :param scatter_cols: column(s) to use for scatter traces. Can provide a single column (as a str), a list of columns,
        or a dict with keys: column names, and values: aliases to use as trace names. Each provided column will be used
        to create one scatter trace.

    :param bar_colors: single color or list of colors to use for bars
    :param scatter_colors: single color or list of colors to use for scatters
    :param bar_opacity: default opacity for all bar traces
    :param scatter_symbol: default marker_symbol for all scatter traces
    :param scatter_mode: default mode for all scatter traces
    :param line_shape: default line_shape for all scatter traces

    :param trace_overrides: used to override/set properties of specific traces. Keys: column names, values: dict of
        kwargs to pass into go.Scatter or go.Bar.
        Ex: trace_overrides={'weight': dict(line_dash='dot'), 'volume': dict(marker_color='slateGrey')}

    :param title: plot title
    :param bar_axis_title: title of bar y-axis (right side of plot)
    :param scatter_axis_title: title of scatter y-axis (left side of plot)
    :param hovermode: Sets fig.layout.hovermode
    :param dragmode: Sets fig.layout.dragmode
    :param selectdirection: Sets fig.layout.selectdirection
    :param x_asfreq: Optional frequency string to prevent interpolation across gaps in data with a datetime x_col.
        EX: if x_col is test_date, setting x_asfreq = 'D' will add rows filled with NaNs for any dates that do not
        appear in the input df. This prevents misleading interpolation of the scatter trace lines across dates with
        no data.
    :param sort: if True, df is sorted in ascending order of x_col. Else, order of provided df is preserved
    :return: go.Figure
    """
    trace_overrides = trace_overrides or dict()
    bar_colors, scatter_colors = [[v] if isinstance(v, str) else v for v in [bar_colors, scatter_colors]]

    bar_cols = _convert_cols_argument_to_dict(bar_cols)
    scatter_cols = _convert_cols_argument_to_dict(scatter_cols)

    if x_asfreq and df[x].is_unique:
        df = df.set_index(x).sort_index().asfreq(x_asfreq).reset_index()

    if sort:
        df = df.sort_values(by=x)

    fig = make_subplots(specs=[[{"secondary_y": True}]], print_grid=False)
    plot_x = x if x not in ['test_quarter'] else f'{x}_str'
    for (col, label), color in zip(bar_cols.items(), cycle(bar_colors)):
        fig.add_bar(
            **_get_trace_kwargs(
                trace_overrides.get(col, dict()),
                x=df[plot_x],
                y=df[col],
                showlegend=True,
                name=label,
                marker_color=color,
                opacity=bar_opacity,
                secondary_y=False,
            )
        )

    for (col, label), color in zip(scatter_cols.items(), cycle(scatter_colors)):
        fig.add_scatter(
            **_get_trace_kwargs(
                trace_overrides.get(col, dict()),
                x=df[plot_x],
                y=df[col],
                showlegend=True,
                mode=scatter_mode,
                line_shape=line_shape,
                name=label,
                marker_symbol=scatter_symbol,
                marker_color=color,
                secondary_y=True,
            )
        )

    fig.update_layout(
        yaxis2=dict(title=scatter_axis_title, overlaying="y", rangemode="tozero", showgrid=True, side="left"),
        yaxis=dict(title=bar_axis_title, showgrid=False, rangemode="tozero", side="right"),
        dragmode=dragmode,
        selectdirection=selectdirection,
        hovermode=hovermode,
        title=title,
    )
    return fig
